---
title: 任务队列
category: 浏览器
tag:
  - 任务队列
  - 宏任务
  - 微任务
  - 延迟队列
comment: false
---

# 消息队列和事件循环

JavaScript 语言的一大特点就是单线程，所谓单线程换句话说，就是同一个时间只能做一件事。当我们要在线程执行的过程中能接收和处理新的任务，就要用到**事件循环**
![](https://static001.geekbang.org/resource/image/9e/e3/9e0f595324fbd5b7cd1c1ae1140f7de3.png)

## 事件循环

事件循环结构类似于如下

```javascript
for (;;) {
  cb();
}
```

一直循环执行线程并执行任务，但是如果线程执行过程中其他线程向渲染主线程推任务的时候，渲染主线程用到了*\*\*消息队列*

## 消息队列

消息队列是一种队列结构，符合先进先出的特点，其他线程的任务会被推入队列，通过**事件循环**不断从队列中拿任务来执行。
![](https://static001.geekbang.org/resource/image/e2/c6/e2582e980632fd2df5043f81a11461c6.png)

这里的 IO 线程就是接收其他进程传过来的任务并将任务添加到队列中。

### 消息队列中的任务类型

现在你知道页面主线程是如何接收外部任务的了，那接下来我们再来看看消息队列中的任务类型有哪些。你可以参考下[Chromium 的官方源码](https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h)，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。

除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

> 注：当我们使用 settimeout 时，settimeout 的回调会被添加到延迟队列中，虽然叫延迟队列但是实际上结构是 hashMap

## 如何安全退出

chrome 页面主线程会在页面退出时设置一个退出标记变量，在事件循环的过程中进行判断决定是否体跳出事件循环

## 页面单线程的缺点

### 1. 任务执行优先级的问题

解决方案：使用微任务

### 2. 单个任务执行时长过久的问题

解决方案：微任务

# 宏任务微任务

## 宏任务

宏任务指的是在消息队列（包括延迟队列）中的任务

### 宏任务包括

- 渲染事件（如解析 DOM、计算布局、绘制）
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
- JavaScript 脚本执行事件
- 网络请求完成、文件读写完成事件

### 宏任务执行流程即从消息队列的取出任务并执行的操作

## 微任务

> 微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。

微任务的出现主要是为了解决 Promise.then 的延迟执行问题

### 微任务包括

- Promise.resolve
- Promise.reject
- MutationObserver

### 微任务执行流程

以代码为例

```javascript
new Promise((resolve, reject) => {
  console.log(0);
  resolve(1);
}).then((val) => console.log(val));
console.log(2);
// 执行结果：0，2，1
```

1. new Promise 为宏任务添加到宏任务队列中
2. new Promise 中存在 resolve(1)为微任务并添加到微任务队列
3. console.log(2) 作为宏任务添加到宏任务队列中
4. 最后按照 ==宏任务队列->微任务队列== 的顺序依次执行任务即可得到结果 0，2，1
