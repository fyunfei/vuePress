# 数据类型
基本数据类型（栈结构）：Number、Boolean、String、undefine、null、Symbol、BigInt
引用数据类型（堆结构）：Array、Object

# 内存空间
JS执行过程中，主要分为三种类型内存空间，分别是**代码空间**、**栈空间**、**堆空间**。

基本数据类型是存放在栈空间中的，引用数据类型是存放在堆中的，在执行上下文中引用的是堆中的地址。

**tips：** 字符串，symbol，bigint虽然是原始类型，但是实际还是存放在堆空间的。
比如字符串的大小可能很大，考虑性能还是存放在堆空间。

**为什么所有类型的数据没有统一使用栈结构存储？**
JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率（栈主要管执行，堆主要管内存）



# 作用域
作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在 ES6 之前，ES 的作用域只有两种：**全局作用域和函数作用域**。
- **全局作用域**中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。
- **函数作用域**就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

但是函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

## 变量提升
### 变量提升存在的问题
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁，例如
```javascript
    for(var i = 0; i < 10; i++){}
    console.log(i) // 10
```
为了解决这两个问题 ES6引入了块级作用域let const；
- 在执行上下文中存在一个词法环境（栈结构）专门维护let/const声明变量
- 单个函数执行上下文查找变量的顺序按照 词法环境->闭包（Closure）-> 变量环境

### 调用栈中存在多个执行上下文时查找变量
```javascript
let t = '外部'
function foo(){
    console.log(t)
}
function fn(){
    let t = '内部'
    foo()
}
fn()
```
我们的想法是打印==内部==，但是实际结果是==外部==
执行栈分析流程：
1. 全局执行上下文的词法环境 t=外部
2. 全局执行上下文的变量环境 foo fn
3. 全局执行上下文入栈
4. fn入栈，分析**词法作用域**，fn的outer指针指向全局执行上下文
5. fn执行上下文的词法环境 t=内部
6. foo入栈，分析**词法作用域**，foo的outer指针也只想全局执行上下文
7. foo执行环境执行

变量查找流程：
1. foo词法作用域 null
2. foo变量作用域 null
3. 到foo的outer指向的执行上下文查找变量
4. 找到t=外部
5. output 外部

函数的作用域链与**词法作用域**有关，我们可以将词法作用域理解为是根据声明位置决定的，例如fn的outer指向全局上下文是因为我们在全局声明的fn。

我们改写下以上方法：
```javascript
let t = '外部'
function fn(){
    let t = '内部'
    function foo(){
        console.log(t)
    }
    foo()
}
fn()
```
这时打印的结果就是==内部==了，因为foo的词法作用域为fn所以outer指向fn，因此查找步骤变成了（以下简写）：
> foo执行上下文->closure->fn上下文->全局执行上下文

经过以上改写我们达到了预期，但是这就引入了新的问题**闭包**

# 闭包
（非官方概念）当外部函数中的内部函数引用了外部函数的局部变量就形成了闭包。很明显，以上的代码就是闭包的一种表现形式。

- 执行上下文中维护了一个Closure栈用来保存当前执行上下文中的被内部函数引用的变量
- 函数销毁后，在下次 JavaScript引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

我们可以在chrome浏览器查看调用栈
![](http://image.followmyheart.cn/closure.png)