---
title: GC垃圾回收
category: 浏览器
tag:
  - 浏览器
  - chrome
  - 垃圾回收
comment: false
---

# GC垃圾回收
有些数据被使用之后，可能就不再需要了，我们把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以我们需要对这些垃圾数据进行回收，以释放有限的内存空间。

根据不同的语言垃圾回收机制可分为**手动回收**和**自动回收**两种策略。

## 调用栈中的回收策略
调用栈中的数据主要是保存在栈结构和堆结构中的，所以在回收时同样针对栈和堆分开进行回收

### 栈中数据回收
栈中数据通过一个**记录当前执行状态的指针（ESP）**来进行垃圾回收的操作，在当前执行上下文执行成功后，ESP指针下移销毁当前栈中的执行上下文。

### 堆中数据回收
在栈中数据回收完毕后，保存在堆中的数据依然占据空间，要回收堆中的垃圾数据，就要用到垃圾回收器了

#### Chrome v8引擎垃圾回收策略
基于**代际假说**：
- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

所以V8引擎会将堆空间分为**新生代**和**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象；这两个区域采用不同的垃圾回收器进行回收：

类型 | 回收器
---|---
新生代 | 副垃圾回收器
老生代 | 主垃圾回收器

#### 垃圾回收器的执行流程
- 标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
- 回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
- 内存整理，处理堆内存清理产生的内存碎片

#### 副垃圾回收器
副垃圾回收器的作用机理是：基于Scavenge算法，把新生代空间分为两个区域（对象区域、空闲区域），新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

**垃圾清理操作流程**：
- 标记垃圾
- 副垃圾回收器会将存活的数据复制到空闲区中
- 对象区域、空闲区域反转

复制操作需要时间成本，所以新生代的空间要尽量小，同时经过两次垃圾回收还存活的会被移动到老生区

#### 主垃圾回收器
标记-清除法来进行垃圾回收

标记-整理解决内存片段不连续的问题

> 补充：早期垃圾回收采用的是引用计数法，具体的流程是判断当前对象是否在其他地方存在引用，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。但是存在循环引用的问题即a=b，b=a时，是不会触发垃圾回收的。
