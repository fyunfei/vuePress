---
title: JS模块化发展
category: js
tag:
  - js模块化
comment: false
---
# 前言
什么是模块化？简单来说就是将一个复杂的应用程序，与其将所有的代码一股脑儿的放在一个文件中，不如按照一定的语法，遵循确定的规范将其拆分到几个互相独立的文件中。这些文件应该具有原子特性，也就是说，其内部完成共同的或类似的逻辑，通过对外暴露一些数据或调用方法，与外部完成整合，使每个文件彼此独立，方便开发者进行开发和维护，模块之间可互相调用和通信，这是现代化开发的基本模式。
# CommonJS
在Nodejs中，每一个文件就是一个模块，具有单独的作用域，对其他文件是不可见的。

## 内容
- 文件即模块
- 模块可以多次引用、加载。在第一次被加载时会被缓存，之后都从缓存中直接读取结果。
- 加载某个模块就是引入模块的module.exports属性
- module.exports 属性输出的是值的拷贝，一旦这个值被输出，模块内再发生变化也不会影响到输出的值
- 模块按照引入顺序进行加载
- module.exports和exports区别

由于Node.js运行在服务器上，所有文件一般都已经存储在本地硬盘中，不需要额外的网络请求进行异步加载，因此通过CommonJS规范加载模块是同步的。只有加载完成，才能执行后续操作。但是如果Node.js在浏览器环境中运行，那么由于需要从服务器端获取模块文件，所以此时采用同步的方式显然就不合适了。为此，社区推出了AMD规范

# 适用于浏览器的AMD（Asynchronous Module Definition）
代表工具类：require.js
require.js的运行原理是通过函数暴露出来的require参数进行模块加载（创建异步script标签），并通过checkLoaded方法吧已经加载完毕的脚本删除

# 规范标准时代：CMD
CMD规范整合了CommonJS和AMD规范的特点，他的全称为Common Module Definition，与require.js类似，CMD规范的实现为sea.js
> 注：目前require.js也支持同步加载

## 与AMD的区别
- AMD遵循依赖前置，需要将模块依赖提前声明
- CMD遵循依赖就近，在使用前引入即可

# 规范标准时代：UMD（Universal Module Definition）
允许环境中同时使用AMD规范与CommonJS规范，该规范的核心思想在于利用立即执行函数根据环境来判断需要的参数类别。

# ES原生时代

ES模块输出的是值的引用

## ES模块为什么要设计成静态的